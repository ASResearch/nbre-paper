%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigplan')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-9999-9/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{positioning}
\usetikzlibrary{fit}
\usetikzlibrary{snakes}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes,arrows,chains}
\usetikzlibrary{calc}
\usetikzlibrary{positioning, fit}
\usetikzlibrary{backgrounds}
\usetikzlibrary{intersections}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Blockchain Runtime Environment: An Accompanying System for Upgrading Blockchain}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{Ben Trovato}
%\authornote{Both authors contributed equally to this research.}
%\email{trovato@corporation.com}
%\orcid{1234-5678-9012}
%\author{G.K.M. Tobin}
%\authornotemark[1]
%\email{webmaster@marysville-ohio.com}
%\affiliation{%
  %\institution{Institute for Clarity in Documentation}
  %\streetaddress{P.O. Box 1212}
  %\city{Dublin}
  %\state{Ohio}
  %\postcode{43017-6221}
%}

%\author{Lars Th{\o}rv{\"a}ld}
%\affiliation{%
  %\institution{The Th{\o}rv{\"a}ld Group}
  %\streetaddress{1 Th{\o}rv{\"a}ld Circle}
  %\city{Hekla}
  %\country{Iceland}}
%\email{larst@affiliation.org}

%\author{Valerie B\'eranger}
%\affiliation{%
  %\institution{Inria Paris-Rocquencourt}
  %\city{Rocquencourt}
  %\country{France}
%}

%\author{Aparna Patel}
%\affiliation{%
 %\institution{Rajiv Gandhi University}
 %\streetaddress{Rono-Hills}
 %\city{Doimukh}
 %\state{Arunachal Pradesh}
 %\country{India}}

%\author{Huifen Chan}
%\affiliation{%
  %\institution{Tsinghua University}
  %\streetaddress{30 Shuangqing Rd}
  %\city{Haidian Qu}
  %\state{Beijing Shi}
  %\country{China}}

%\author{Charles Palmer}
%\affiliation{%
  %\institution{Palmer Research Laboratories}
  %\streetaddress{8600 Datapoint Drive}
  %\city{San Antonio}
  %\state{Texas}
  %\postcode{78229}}
%\email{cpalmer@prl.com}

%\author{John Smith}
%\affiliation{\institution{The Th{\o}rv{\"a}ld Group}}
%\email{jsmith@affiliation.org}

%\author{Julius P. Kumquat}
%\affiliation{\institution{The Kumquat Consortium}}
%\email{jpkumquat@consortium.net}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Blockchain is a distributed database \cite{crosby2016blockchain}
that each peer holds the entire information of the database.
The information of each one is a growing list of records, called \textit{blocks},
that are linked using cryptography \cite{blockchainwikidef}.
Each block contains a cryptographic hash of the previous block and
\textit{transactions}.
Underlying \textit{consensus protocol} \cite{gilad2017algorand,kiayias2017ouroboros,hanke2018dfinity}
ensures blockchain peers share the same state.

Based on the basic concept of blockchain (block, transaction and consensus
protocol), arguments are gradually proposed because of the different
requirements in different scenarios of blockchain.
Or with the development of blockchain technology and deeper thinking of
blockchain, ideas on blockchain optimization are raised one by one.

Therefore, it is necessary to update blockchain features, upgrade blockchain as
well, when newly comming proposal arrives.

For traditional centralized system, there are two ways for upgrade
\cite{softwareupgradewikidef}, offline and online.
In offline way, software company deploys installation packages to the
centralized server, after that, client downloads packages actively, and then
installs packages and upgrades system. In online way, client local version and
server latest version will be checked, downloading and installing packages if
client version is not the latest. System upgrade executes passively in online
way.

For traditional distributed system, like server clusters,
content distribution networks, peer-to-peer system and sensor networks,
upgrade includes the step of \cite{ajmani2003scheduling}:
1) install upgrades at logically centralized
upgrade server by a trusted party; 2) upgrade server advances the version
number of system and makes the new upgrade available for download; 3) download
the upgrade for the new version from upgrade server and be affacted by the
upgrade.

However, it's not easy to upgrade blockchain, permissionless blockchain in
particular, peers of which are free to participate or leave without permission,
because blockchain is decentralized and peers in blockchain are untrusted.
Unlike traditional upgrade service, there is no such a trusted institution to
deploy installation packages in blockchain, or there is no centralized peers to
provide installation packages download service for upgrade in blockchain.
Even more, peers' behavior in blockchain is arbitrary, one could choose to
upgrade or keep as it is, making it impossible to enforce all peers upgrade.

When upgrading blockchain, usually a \textit{soft fork} or a \textit{hard fork}
is introduced. A soft fork is backward compatible upgrade,
agreement will be reached eventually even though a temorary fork may caused.
In contract, a hard fork is a permanent divergence from the previous version of
blockchain, which is inevitable unless all participants upgrade to the new
version of blockchain in order to continue verifying and validating new blocks
of transactions.

A hard fork sometimes brings bad effect to the community.
In the case of Bitcoin \cite{bitcoin}, controversy still abounds over the block
size debate among developers, miners and users, ending in the famous hard fork
of Bitcoin Cash \cite{bitcoincash} out of Bitcoin.
Moreover, The DAO problem \cite{thedaowikidef} of Ethereum \cite{ethereum}
gives rise to unintended side effect such as Ethereum and Ethereum Classic
\cite{ethereumclassic} duplicate assets and division of its community.

Besides, for a digital currency exchange, who has its own peers, it will
increase the maintainance cost of the exchange and cause unnecessary economic
losses for blockchain upgrade.
Blockchain upgrade means the exchange should be informed in
advance for fetching the latest version of blockchain code, and compiling,
testing, deploying it. If failed, further steps should be taken with the
help of blockchain developers. All of these increase the maintainance cost of
the exchange.
On the other hand, blockchain upgrade means peers of the exchange may not
provide service during the period of upgrade, which enables deposition and
withdrawal operation failed until upgrade finish.
According to CoinMarketCap \cite{coinmarketcap} historical data of Bitcoin,
daily average trading volume for year 2018 is around 6 billion USD.
Assuming that on-chain trading volume is one-tenth of off-chain's (exchange
internal), and processing fees is 1\textperthousand, it brings about 25,000 USD
losses a hour because of disabling deposition and withdrawal.

Tezos \cite{tezos} is the first permissionless blockchain, who gives
the concept of self-amendment, and accepts and deploys protocol upgrades
without the need to hard fork.
The candidates of amendment proposal are voted by \textit{StakeHolders}, and
then achieve upgrade by exposing two procedures functions
\cite{goodman2014tezos}
$set\_test\_protocol$ and $promote\_test\_protocol$ to the protocol.
Since Tezos' implementation programming language OCaml is functional
programming, supporting the feature of compilation on the fly, there will
provide service continuously during the upgrade time.

Nevertheless, the way of Tezos self-amendment, or upgrade in other words,
still has limitations.
First of all, Tezos' upgrade functions replace the current protocol
with a new one, instead of keeping the historical protcols available at the
same time, making it impossible to run the previous after done unless
reverse replacement again.
Suppose that Tezos is in the situation where the current protocol is the latest
while transactions to be verified and validated isn't. In that case, the latest
protocol must cover all possibilities that Tezos may reach, which in require of
protocol backward compatible, and makes protocol logic complicated further.
Second, protocols being executed concurrently is impossible neither, much less
correctness of concurrent execution results.

In conclusion, limitations, from which blockchain upgrade may suffer,
including but not limited to those are as follows:
\begin{itemize}
  \item Traditional upgrade way is not fit for blockchain, because of the
    feature of untrusted and decentralized of blockchain.
  \item Usually, a hard fork it may raise, which afftects the community with
    split.
  \item Unfriendly service and unnecessary economic losses for exchanges.
  \item Multi-version protocol execution and the correctness of concurrent
    execution are unsolved.
\end{itemize}

In this paper we describe
\textit{Blockchain Runtime Environment} (BRE) addressing these limitations.
BRE provides the environment for upgrading, both permissionless and
permissioned blockchain, with continuous service during the upgrade period
without hard fork.
Generally, BRE is an accompanying system that is not going to run
independently,  but will interact with blockchain when manipulating upgrade.
Specifically, for a blockchain node, which has installed BRE, is
running a blockchain client process and a friend process BRE at the same time.

\section{Background}

\section{Architecture}
In this section, we first define blockchain protocol and version, and illustrate
blockchain abstract description based on the definition. We then explain the
architecture designing purpose and principle. After that, we introduce Blockchain
Runtime Environment architecture, system components and working flow included.

\subsection{Overview}
%\textit{Blockchain Runtime Environment} (BRE) is an accompanying system for upgrading,
%both permissionless and permissioned blockchain.
%Generally, BRE is not going to
%run independently, but will interact with blockchain when manipulating
%upgrade. Specifically, for a blockchain node, which has installed BRE, is
%running a blockchain client (or simply client) process and a friend process BRE
%at the same time.

Upgrading blockchain, actually, is upgrading blockchain protocol.
Blockchain protocol is the parameters that blockchain holds, including block
generation rate, block size, transaction fees and et al. To be
more broadly, any line of code in blockchain system is blockchain protocol.
Blockchain upgrade happens when blockchain system meets serious problem,
which results in bug fix in an emergency; or when new features launches,
leading to functions developing correspondingly. Both of these situations
are blockchain upgrade, at the same time, introduces blockchain system code
upgrade (optimization and revise), which explains blockchain protocol is
blockchain system code itself.

However, it should be noted that the application layer (based on blockchain)
upgrade is not blockchain upgrade. Smart contract upgrade for
example, is outside blockchain upgrade scope.

Blockchain protocol version, which also represents as blockchain system
version, increases after blockchain protocol enforcing upgrade. For traditional
software upgrade, only the lastest version of the system needs to be
maintained, and backward compatible is made when the latest is
released. It barely cares about the historical versions of the system. But in
contrast, blockchain system needs to retain all historical protocols and its
versions. If not, transactions validation may fail when the absent of specific
version of protocol, because data consistency is strictly required for
blockchain system.

In view of above-mentioned description, blockchain node, blockchain protocol
and blockchain node state is as follows:
\begin{itemize}
  \item $n_i$ is blockchain node with identity $i=1,2,...$;
  \item $p_j$ is blockchain protocol with version $j=1,2,...$;
  \item $S_{m}^{j}$ is blockchain node state, where the node holds a set of $m$
    kinds of historical protocols $\{p_1,p_2,..,p_j,..,p_m\}$, for
    $1{\leq}j{\leq}m$, and the node is running with protocol $p_j$ currently.
\end{itemize}

Thus, we further abstract blockchain system along with node state.
For any node $n_i$ of blockchain, at moment $t$,
the node state is $S_{m}^{j}$, which means the node holds the set of protocols
$\{p_1,p_2,..,p_j,..,p_m\}$, and now the node's running protocol is $p_j$.
Obviously, blockchain nodes' state may differ from each other: the set of
protocols are originally different or the current running protocols are
different. By default (not receiving requests from client),
blockchain nodes' state is always $S_{m}^{m}$, namely each node has entire
historical protocols and runs the lastest protocol, only if last irreversible
block (LIB) has been validated.

\begin{figure}
  \includegraphics[width=\linewidth]{pdfs/fig1.pdf}
  \caption{Blockchain system abstraction}
\end{figure}

As illustrating in Fig. 1-a), suppose that there are at most three protocols
(set $\{p_1,p_2,p_3\}$) for the having-LIB node. Therefore,
blockchain node $n_1$, $n_2$, $n_5$, $n_7$ are in the state of default
(state $S_3^3$), while not for the others. Several reasons result in node not
running in default state: 1) Node is in the stage of block synchronization,
executing one historical protocol for block validation, such as node $n_3$ and
$n_4$; 2) Node received external request, and is running a specific assigned
protocol, like $n_6$ and $n_8$.

As soon as new protocol $p_4$ is deployed to blockchain system,
$p_4$ will be broadcast to all nodes. After all, nodes with having-LIB
will receive $p_4$. Finally, nodes will add $p_4$ to their protocol set, start
running $p_4$, and update their default state to $S_4^4$, as Fig. 1-b) says.

Three more need to take into concern when designing and implementing its
architecture:
\begin{itemize}
  \item Protocol deployment. Base on the description of protocol in the narrow
    and the general sense, protocol, with the underlying libraries of
    blockchain system, implements some requirements or functions; Furthermore,
    protocol as a part of the underlying libraries, provides blockchain services.
    In a word, protocol actually is blockchain system code. On the other hand,
    protocol needs to be deployed to the blockchain system and broadcast to
    other nodes. Fortunately, blockchain's sending transaction property meets
    the need of protocol deployment and broadcasting. So, consider of packing
    protocol (source code) into transaction payload, and deploy it by just
    sending a special transaction.
  \item Protocol management. Previously, it has stated the fact that blockchain
    upgrade produces various versions of protocol, resulting in the
    requirement of protocol version control. Managering newly comming protocol
    and responsing the client's request for specific protocol executing result
    are the main parts of protocol management. For newly comming protocol,
    which is packed into the transaction payload, it needs to be parsed from
    block tranaction and collected, and then saved persistently. For responsing
    the request, it needs to retrive the protocol that matches the query
    condition efficiently for further execution.
  \item Protocol execution. Generally, protocol execution proceeds right after external
    request arrives. As mentioned above, protocol actually is source code, and
    source code representation executable if it can be executed directly as in
    machine code, or indirectly using a interpreter. Unfortunately, protocol
    entity, coming from transaction payload parse and collection, is not
    representation executable: protocol is high-level language, and a
    high-level language finally become executable until compilation procedure
    (preprocess, compile, assemble and link) done; The same to its
    dependencies. But if manipulating compilation procedure each time when
    request arrives seems impractical, which will affect the efficiency of
    execution, lead to disastrous results for performance.

    Just-In-Time technology is the answer of protocol-execution problem. If
    protocol entity is not source code anymore, but a translated language
    representation called protocol representation that could be executed
    indirectly by JIT interpreter. There will be no compilation procedure when
    executing protocol representation but check variables and functions in
    symbol table and interprete dynamically. Thus involve translation from
    protocol to protocol representation when parsing transaction payload for
    real protocol entity.
\end{itemize}

Blockchain Runtime Environment architecture consists of components (see in Fig.
2) including:
\begin{itemize}
  \item \textit{Protocol representation manager}
  \item \textit{Protocol representation database}
  \item \textit{Compiler frontend}
  \item \textit{Intermediate representation module manager}
  \item \textit{Just-In-Time engine}
\end{itemize}

\begin{figure}
  \includegraphics[width=\linewidth,trim={0 0 .8cm 0},clip]{pdfs/fig2.pdf}
  \caption{Blockchain Runtime Environment architecture}
\end{figure}

The function of these components along with protocol deployment, upgrade and
execution procedure will be illustrated in the next three sections.

\subsection{Protocol Deployment}

\begin{figure}
  \includegraphics[width=\linewidth,trim={0 0 2.2cm 0},clip]{pdfs/fig3.pdf}
  \caption{Blockchain transactions model}
\end{figure}

Fig. 3 shows that blockchain system in a logical-level way. Blocks are linked
one by another, because of child block holding its parent block hash. In a
block, transactions are deterministic in specific order. For each transaction,
it has transaction meta data (source, target, value, type, et al.) and
transaction payload. Usually, transaction payload is empty for transfer
transaction, but argument or smart contract content for smart contract call
or deployment transaction respectively.
The protocol for blockchain upgrade comes from transaction payload
(Sec. 3.1). Specifically, protocol, actually high-level source
code, and its meta data (protocol name, protocol version and its dependencies'
meta data) will be organized and packed into transaction payload field.
Only one version of protocol is allowed in one transaction. The committee
signatures protocol transaction and broadcasts it. Finally, protocol
is successfully deployed when nodes receive the transaction and validate it in
the end.

\textit{Discussion on design choices.} The way of protocol deployment takes use
of blockchain transacton's feature: carrying information and spreading to all
nodes. Deploying protocol by sending transaction with protocol in it instead of
active downloading from centralized server is more reasonable in blockchain
world. On the other hand, unlike traditional distributed system or permissioned
blockchain, who have an identity, nodes are free to join in or leave in
permissionless blockchain, thus makes it impossible to determine the set of
upgrade nodes in advance.

The committee plays a important role in protocol deployment phase. If only one
person, instead of the committee, signatures the protocol transaction
and broadcasts it, which makes no different from centralized system deploying
upgrade software. What's more, protocol transaction has the super
privilege of upgrading underlying blockchain system. It will be unsafe if the
privilege is in control of someone. The committee way of protocol deployment
weakens the influence of each one. Anyone who intents to do evil is limited.
The committee has to come to an agreement before signaturing and deploying the
transaction.

It's very similar to smart contract
deployment, call and execution phase when compared with protocol upgrade
procedure. Is it possible to manipulate blockchain upgrade by smart contract
regardless of protocol? The answer is definitely yes, in some conditions.
However, smart contract is limited by authority in aspect of deployment and
on-chain data interaction. Smart contract is application layer protocol,
anyone has the right to deploy arbitrary logic of smart contract even
it behaves malicious. If malicious smart contract has the privilege of
upgrading blockchain system, it does cause disaster that cannot imagine.
Smart contract has access to on-chain data only if corresponding
interface has been defined,
while protocol is free to invoke any functions of BRE. Besides,
protocol could even provide Turning Complete services for blockchain system,
which smart contract would never achieve.


\subsection{Protocol Upgrade}
After protocol deployment phase, blockchain system upgrade goes to the next
protocol upgrade phase. In this phase, BRE's components \textit{protocol
  representation manager} (PRM), \textit{compiler frontend} (CF) and
\textit{protocol representation database} (PRD) are involved in. PRM is responsible
for protocol collection and protocol version management, with the help of CF
and PRD for protocol compilation and protocol representation persistence
respectively.

When protocol transaction arrives, PRM parses transaction payload, and
obtains the raw protocol and its meta information just the way they organized.
Protocol will be sent to CF for further compilation. CF parses protocol,
checking it for errors, translates protocol
into low-level protocol representation and then protocol representation returns.
Finally, protocol representation and its meta data dumps to PRD for persistence
in forms of key-value pair.

On the other hand, when client sends request (protocol name and version)
to BRE for the execution result of specific protocol, PRM is firstly informed.
After that, PRM loads the corresponding protocol representation as well as its
dependencies from PRD and sends to \textit{intermediate representation module
  manager }(IRMM) for execution and return.
In the end, PRM responses the execution result for the request.

\textit{Discussion on design choices.}
Most of the clients do not aware of blockchain's upgrade unless the client
gets BRE response that can identify upgrade event after requesting. Thus the
hallmark of successful upgrade is that the response that the client gets is
exactly the protocol running result supposed to be.
Therefore, protocol upgrade has already done after protocol representation
dumped to the database, all clients' request redirecting to the corresponding
protocol execution.

Traditionally, there are two approaches to keep and execute protocol: keep raw
protocol (high-level language) in database, compiling and linking in execution
phase; or compiling and linking as soon as protocol parsed from transaction
payload, keep protocol binary (machine code) in database, executing directly.
The first approach of compiling and linking in execution phase becomes
impractical when client requests frequently, making it impossible to response
within the given time. While the second could execute faster, but may cost too
much storage resource because protocol binary is larger.

In consideration of the trade-off between time and space complexity, we
introduce protocol representation. Protocol representation gains the benefits
of both raw protocol and protocol binary. Protocol representation is not
machine code but could be executed by interpreter.

\subsection{Protocol Execution}
Protocol execution part consists of \textit{intermediate representation module
  manager} (IRMM) and \textit{Just-In-Time engine} (JE). IRMM receives protocol
representation from PRM, for each protocol representation, IRMM transforms it
into internal data structure \textit{Module} for adapting JE's interface.
On the other hand,
IRMM provides cache and concurrency technology for execution performance.
Cache technology enables expected \textit{Module} reading directly from memory,
instead of accessing to PRD for protocol representation and transforming it.
Concurrency technology makes it possible to run several protocols at the same
time, taking full use of computer resources.
JE, actually, is the simple wrapper of Just-In-Time interpreter. It receives
\textit{Module} and function entry point, interpretes dynamically, and returns
execution result.

\textit{Discussion on design choices.} Although concurrency technology helps to
improve the efficiency of protocol execution, it brings resource race problem
as well. If two protocols are executed concurrently, one is reading global
resource while the other is updating it. This will cause different results
because reading and updating operation is unsafe in multi-thread program.
Generally, \textit{lock} is introduced to avoid resource race problem. But it's
unsafe to provide global lock for inexperienced developer, who may cause
deadlock inadvertently.

\textit{Software transactional memory} (STM) is one of the answer for concurrency
execution: 1) STM is lockless during the execution time; 2) Execution result is
simulated and will rollback if falied before it finally writes to the memory.
These two
features ensure the efficiency of concurrency execution as well as its safety.
Therefore, STM code will be generated with program instrumentation before
transformed into \textit{Module}.

However, STM technology is not apply to those who are out of memory operation,
like input/output operation, lock operation, thread operation and et al.
For those STM could not deal with, lock technology is necessary.
With the help of program automatic analysis, those who have no concurrency
execution problem operations will be ignored, while those do have will be
locked automatically during the operation period.

\section{Implementation}
\section{Evaluation}
%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
