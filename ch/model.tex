% !TEX root = main.tex

\section{系统模型}

\subsection{协议及版本定义}
区块链系统的升级其实质是对区块链系统中协议的升级。
一般而言，区块链系统中的协议指系统中定义的元数据，例如出块的速率、区块的容量、矿工费用等。
更加广义地说，支撑区块链系统运行的每一行代码都可称为协议。
当区块链系统出现安全漏洞问题，需要进行紧急修复时，对系统的任何改动认为是协议的升级；
再如，当系统增加新的特性，推出新的功能（新增接口、提出新的共识算法）时，也可认为是协议的升级。
需要指出的是，基于区块链系统之上的应用层升级不属于系统升级，例如对智能合约的升级不在区块链系统升级的范畴。

区块链系统的每一次协议升级，都产生了一个协议版本，也代表了区块链系统的版本。
对于传统软件，只需要维护系统的最新版本，并在最新版本发布时向后兼容。
但对区块链系统而言，数据的一致性具有严格要求，区块链系统需要执行验证已有交易，区块链系统需要保留所有历史（协议）版本信息。

\subsection{模型表示}
首先我们给出系统模型中设计的符号表示。
\begin{itemize}
  \item $n_i$表示节点编号，其中$i=1,2,..$。
  \item $p_j$表示协议版本，其中$j=1,2,..$。
  \item $S_{m}^{j} =
    \{p_1,p_2,..,\textcolor{red}{p_j},..,p_m\}$表示节点状态，其中$j=1,2,..$且$j{\leq}m$。
    具体来说，节点中包含$1,2,..,m$共$m$个版本的协议，当前运行的协议为$p_j$。
\end{itemize}

区块链系统可以抽象地表示为如下的模型：

\begin{tikzpicture}

\pgfmathsetmacro{\OTX}{3.0}
\pgfmathsetmacro{\INY}{0.3}
\pgfmathsetmacro{\OTY}{3.0}

\node [] (start) at (0, 0) {};
\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n1) at
($(start.east) + (\OTX, 0)$) {$S_{3}^{3}$};
\node [] at ($(n1.north) + (0, \INY)$) {$n_1$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n2) at
($(n1.east) + (\OTX, 0)$) {$S_{3}^{3}$};
\node [] at ($(n2.north) + (0, \INY)$) {$n_2$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n3) at
($(n2.east) + (\OTX, 0)$) {$S_{1}^{1}$};
\node [] at ($(n3.north) + (0, \INY)$) {$n_3$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n4) at
($(n1) + (\OTX/2+\INY, -\OTY)$) {$S_{2}^{2}$};
\node [] at ($(n4.north) + (0, \INY)$) {$n_4$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n5) at
($(n2) + (\OTX/2+\INY, -\OTY)$) {$S_{3}^{3}$};
\node [] at ($(n5.north) + (0, \INY)$) {$n_5$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n6) at
($(n1) + (0, -\OTY*2)$) {$S_{3}^{1}$};
\node [] at ($(n6.north) + (0, \INY)$) {$n_6$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n7) at
($(n6.east) + (\OTX, 0)$) {$S_{3}^{3}$};
\node [] at ($(n7.north) + (0, \INY)$) {$n_7$};

\node [align=center, minimum height=5ex, minimum width=6ex, draw] (n8) at
($(n7.east) + (\OTX, 0)$) {$S_{3}^{2}$};
\node [] at ($(n8.north) + (0, \INY)$) {$n_8$};

\draw [-] (n1.east) -- (n2.west);
\draw [-] (n2.east) -- (n3.west);
\draw [-] (n4.east) -- (n5.west);
\draw [-] (n6.east) -- (n7.west);
\draw [-] (n7.east) -- (n8.west);

\draw [-] ($(n1.south) + (-\INY, 0)$) -- ($(n6.north) + (-\INY, 0)$);
\draw [-] ($(n3.south) + (\INY, 0)$) -- ($(n8.north) + (\INY, 0)$);

\draw [-] ($(n1.south) + (\INY, 0)$) -- ($(n4.north) + (-\INY, 0)$);
\draw [-] ($(n6.north) + (\INY, 0)$) -- ($(n4.south) + (-\INY, 0)$);
\draw [-] ($(n2.south) + (-\INY, 0)$) -- ($(n4.north) + (\INY, 0)$);
\draw [-] ($(n7.north) + (-\INY, 0)$) -- ($(n4.south) + (\INY, 0)$);

\draw [-] ($(n2.south) + (\INY, 0)$) -- ($(n5.north) + (-\INY, 0)$);
\draw [-] ($(n7.north) + (\INY, 0)$) -- ($(n5.south) + (-\INY, 0)$);
\draw [-] ($(n3.south) + (-\INY, 0)$) -- ($(n5.north) + (\INY, 0)$);
\draw [-] ($(n8.north) + (-\INY, 0)$) -- ($(n5.south) + (\INY, 0)$);

\end{tikzpicture}

对于区块链系统中的任意一个节点$n_i$，在某一时刻$t$，节点状态为$S_{m}^{j}$，即节点中包含协议集合$\{p_1,p_2,..,p_j,..,p_m\}$，且当前运行的协议为$p_j$。
显然，对于不同节点，节点状态存在差异（节点中包含的协议集合不同或当前运行的协议不同）。
在默认条件下（未被外部请求调用），对于已经达成共识的节点的状态总是为$S_{m}^{m}$（$p_m$为最新协议），即包含了完整的协议集合，运行着最新的协议。

以上述模型为例，区块链系统中节点$n_1$、$n_2$、$n_5$、$n_7$处于默认状态下（$S_{3}^{3}$，包含协议集合$\{p_1,p_2,p_3\}$，当前运行协议$p_3$），其余节点的状态与默认状态不一致。
导致节点运行在非默认状态下的原因有：
1）节点正在进行数据同步，执行历史协议版本、验证交易，如$n_3$、$n_4$；
2）节点被外部请求调用，正在执行外部指定的协议，如$n_6$、$n_8$。

当区块链系统中发布协议（$p_4$）更新时，协议会被广播到全网，且只有达成最新共识的节点会接收到$p_4$。
$p_4$会更新到节点包含的协议集合，且更新节点当前运行的协议，即节点状态更新为$S_{4}^{4}$。

\subsection{协议发布}
基于对区块链系统中协议的狭义、广义定义，协议以区块链系统作为底层库，实现某种需求或功能；
更进一步，协议可以实现底层库的功能，成为提供服务的一方。
总之，协议实质上是一份源代码。
另一方面，协议需要在区块链系统中发布，达成共识，并广播到全网，而区块链系统中交易的性质恰好满足协议发布、共识、全网广播的性质，可以考虑协议同交易一起打包。

\subsection{版本管理}
文章之前已经阐述在区块链系统升级协议时，会有不同版本的协议产生，这就导致需要对协议版本进行管理。
协议的版本管理主要分为两部分：处理接收的更新协议，和返回对于某个协议的请求。
对于前者，在接收到新协议（上文已经提到可通过交易发布协议，即接收交易）时，能够解析交易、提取协议；
更进一步，为了维护不同版本的协议，需要保存协议。
对于后者，在接收到请求时，能够快速检索满足条件的协议。

\subsection{执行引擎}
一般而言，外部请求某个协议后，紧接着是对该协议的执行。
对于系统而言，执行效率是需要考虑的问题。
上文中已经提到协议的本质是源代码，执行源代码的前提条件是源代码可被机器识别，且相关依赖已准备就绪。
显然，从交易中解析提取的协议实体并不满足条件：
协议源代码是高级语言，机器无法直接识别执行，需要编译、链接、解释；
其相关依赖也面临着同样的问题。
然而，在每一次请求到来时，再对协议编译、链接、解释又显得不切实际，这严重影响了系统的执行效率，对性能造成灾难行的后果。

解决方案之一是上文提及的即时编译技术。
外部请求返回的协议实体是已被翻译的语言，即时编译引擎在执行时只需要去查找相关符号是否在库的符号表中，无需编译、链接过程，可动态地解释。
以上方案要求解析交易、获取协议实体时额外再做一件事：
将协议转化为可被即时编译引擎直接执行的语言。
如此，便保证了在外部请求下，返回的协议实体可被直接执行。
