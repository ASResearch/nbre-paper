% !TEX root = main.tex

\section{背景及相关技术}

本章主要介绍区块链系统升级背景及相关技术。
由于区块链系统升级而引入的执行协议多版本的需求，本章将讨论即时编译技术；
对于执行协议多版本的并发问题，本章将进一步讨论软件事务内存。

\subsection{区块链升级现状}

比特币，作为区块链的太初应用，与以太坊，支持图灵完备的智能合约，在其发展历程中，都经历了不同规模的系统升级~\cite{bitcoinupgrade}~\cite{ethereumupgrade}。
比特币因为区块容量的争议而进行协议升级~\cite{bitcoincash}，或为了支持通用图像处理单元挖矿而进行系统升级~\cite{bitcoingold}。
以太坊在版本迭代过程中，进行了一系列的既定升级，当然，也有因为受到外部攻击（例如The
DAO事件~\cite{thedaoattack}、拒绝服务~\cite{eip150}）而进行的修复升级。

以上，对区块链系统任何改动的升级，都无法避免硬分叉。
在比特币基础之上，硬分叉出了比特现金和比特黄金；
同样的对于以太坊，有以太经典和以太坊之别。
在其衍生的硬分叉基础之上，区块链系统升级又会有出现新的硬分叉的可能。

\subsection{即时编译技术}

区块链系统中的协议代码，通过编译链接，组织成不同形式的目标文件供调用执行~\cite{bryant2003computer}。
最直观的方式，协议代码与区块链系统文件，通过静态链接的方式生成可执行目标文件。
该可执行目标文件是完全链接、可加载、可运行的，无需再进行任何符号解析、重定向的工作，可直接在平台运行。
然而，其缺点显而易见，每一类协议代码、每一个版本的协议代码，都会拥有一份系统目标文件的拷贝，这无疑是对磁盘和内存空间的浪费。
每当运行协议代码时，磁盘和内存的读写严重影响了程序的执行效率；
若仅保留协议源代码，在需要时编译，编译的时间又无法确定，同样无法满足系统实时性的需求。

编译系统中库的概念的引入解决了程序执行低效的问题。
将区块链系统所有相关目标模块打包成一个单独的文件，称为静态库。
协议代码在链接静态库时，仅拷贝被协议代码引用的目标模块，减少了可执行文件在磁盘和内存中的大小。
共享库（又称动态库）进一步优化了静态库拷贝目标模块的缺陷，共享库作为一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。
在任何给定的文件系统中，一个库只有一个共享目标文件，所有引用该库的可执行目标文件都共享这个库的代码和数据。

然而，由于区块链系统中协议多版本的需求，引入库的链接方式仍存在局限性。
一般而言，协议代码会编译链接成共享目标文件，加载到内存中；
然而，对于同一种协议的不同版本的共享目标文件，却不能同时加载到内存中。
上文已经说明了在共享库的模式下，一个库只有一个共享目标文件。
同一种类型各个版本的协议，具有相同的程序名称，同时加载存在程序名冲突的问题。
对于某些编译器而言，即使加载不同版本的协议，若在同一域名空间下存在相同的函数名、参数及返回类型，仍然有链接失败的风险。

既然协议代码无法组织成共享库目标文件的形式，区块链系统中的协议代码在被解析时，将以何种形式编译链接。
一般而言，编程语言的翻译有两种形式~\cite{aycock2003brief}：
将高级语言（例如C语言）翻译成更易于机器识别的汇编语言，后者可能被继续翻译成更加底层的语言；
或者，直接将高级语言解释成机器可执行程序。
前者被称为静态编译，后者被称作动态解释，两种形式是对程序时间与空间上的权衡。
解释型语言其占用的空间小，可移植性更高，但是执行的时间会更长；
编译后的语言执行得更快，特别是当被编译成可以被底层硬件直接执行时，但是它所占的空间会更大。
协议代码的翻译形式将是程序运行在时间和空间上的取舍。

\subsection{软件事务内存}

区块链系统中协议多版本需要被并发地执行。
由于区块链系统中存在不同类型、不同版本的协议，客户端对于协议的请求（调用）是不可预测的。
当客户端的请求被响应（执行）时，由于协议之间具体实现的差异性，存在过量占用计算资源或读写资源的可能，这导致了协议执行时间的不确定性。
具体来说，一份协议源代码从开始到执行结束，占用大量的时间，阻塞其它协议，会导致其它协议无法响应。
即使不存在协议执行阻塞的情况（单个请求都能被立即处理，及时响应），当协议请求的压力逐渐增大时，响应请求受到的影响被逐渐放大，最终导致无法立即响应请求。

协议的并发执行引入了临界资源竞争问题。
临界资源竞争是因为协议代码中直接（直接使用）或间接（例如被函数调用，对协议代码不可见）地使用了共享变量，在协议代码并发执行时，出现执行结果不确定的情况。

由系统提供对临界资源的原子化操作或者由系统提供全局化锁，是两种解决临界资源竞争问题的方式。
系统提供临界资源的原子化操作是不切实际的：
随着系统复杂性增加，临界资源数量的增多，原子化操作指令是不可扩展的；
特别是当临界资源之间相互影响时，复杂程度可想而知。
系统提供全局化锁同样无法接受：
锁的操作增加了协议代码的开发难度，且不同协议之间行为不可知，容易造成死锁；
锁的粒度太大，并发执行方式就退化成了串行执行方式，影响协议执行效率。
